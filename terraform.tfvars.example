##########################################
#            Cloud Providers             #
##########################################
deploy_aws = true

##########################################
#           AWS Configuration            #
##########################################
# AWS Region
aws_region = "us-west-2"

# Tags
aws_tags = {
  Environment = "production"
  Owner       = "your-team"
  Project     = "webapp"
}

# Domain Configuration
aws_domain_name               = "example.com"       # Replace with your actual domain
aws_subject_alternative_names = ["www.example.com"] # Set this to [] if not needed. Can include subdomains.

# VPC Configuration
# Make sure these CIDR blocks do not overlap with your existing network
aws_vpc_cidr                = "10.0.0.0/16"
aws_public_subnet_cidrs     = ["10.0.1.0/24"]
aws_private_subnet_cidrs    = ["10.0.101.0/24"]
aws_vpc_flow_logs_role_name = "VPCFlowLogsRole" # Set a unique IAM role name for VPC Flow Logs.

# Application Load Balancer Configuration
# This is the entry point for all public traffic to your containers
# Adjust security group CIDR blocks as needed for your security requirements
aws_alb_name                       = "webapp-alb"    # Set a unique name for the ALB
aws_alb_security_group_name        = "webapp-alb-sg" # Set a unique name for the ALB security group
aws_alb_security_group_description = "Security group for the Application Load Balancer"
aws_alb_ingress_cidr_blocks_http   = ["0.0.0.0/0"] # Open HTTP to the world or restrict to trusted IPs
aws_alb_ingress_cidr_blocks_https  = ["0.0.0.0/0"] # Open HTTPS to the world or restrict to trusted IPs
aws_alb_egress_cidr_blocks         = ["0.0.0.0/0"] # Allow all outbound traffic or restrict as needed

# ECS Fargate Configuration
# This project uses AWS ECS Fargate to run containers without managing servers
aws_ecs_cluster_name                      = "webapp-cluster"       # Set a unique name for the ECS cluster
aws_ecs_task_execution_role_name          = "ECSTaskExecutionRole" # Set a unique IAM role name for ECS task execution
aws_ecs_security_group_name               = "webapp-ecs-sg"        # Set a unique name for the ECS security group
aws_ecs_security_group_description        = "Security group for ECS tasks"
aws_ecs_security_group_egress_cidr_blocks = ["0.0.0.0/0"]        # Allow all outbound traffic or restrict as needed
aws_ecs_task_definition_family_name       = "webapp-task-family" # Set a unique family name for the ECS task definition
aws_ecs_service_name                      = "webapp-ecs-service" # Set a unique name for the ECS service

# Database Configuration
# Define your databases here if needed. You can configure multiple databases with different engines.
# Supported engines: "rds" for Amazon RDS, "dynamodb" for Amazon DynamoDB
# By default, all RDS databases are accessible from all ECS tasks. Adjust security groups as needed.
# Ensure that the secrets or parameters for database passwords are created in AWS Secrets Manager or Parameter Store.
aws_databases = {
  mypostgresdb = {
    engine                          = "rds"                                                                    # "rds" or "dynamodb"
    rds_instance_class              = "db.t3.micro"                                                            # RDS instance class
    rds_engine                      = "postgres"                                                               # RDS engine (e.g., "mysql", "postgres", etc.)
    rds_engine_version              = "13.4"                                                                   # RDS engine version
    rds_db_name                     = "mydb"                                                                   # Initial database name
    rds_username                    = "admin"                                                                  # Master username
    rds_password_arn                = "arn:aws:secretsmanager:us-west-2:123456789012:secret:mypostgresdb_pass" # ARN of the Secrets Manager secret or Parameter Store ARN containing the password
    rds_allocated_storage           = 20                                                                       # Storage in GB
    rds_storage_type                = "gp2"                                                                    # Storage type (e.g., "gp2", "io1", etc.)
    rds_multi_az                    = false                                                                    # Multi-AZ deployment
    rds_port                        = 5432                                                                     # Database port
    rds_publicly_accessible         = false                                                                    # Whether the DB is publicly accessible
    rds_skip_final_snapshot         = true                                                                     # Skip final snapshot on deletion
    rds_ingress_allowed_cidr_blocks = ["0.0.0.0/0"]                                                            # CIDR blocks allowed to access RDS
    rds_egress_cidr_blocks          = ["0.0.0.0/0"]                                                            # CIDR blocks allowed for RDS egress
  }
  mydynamodb = {
    engine                  = "dynamodb"        # "rds" or "dynamodb"
    dynamodb_table_name     = "my-dynamo-table" # DynamoDB table name
    dynamodb_hash_key       = "id"              # Hash key attribute name
    dynamodb_hash_key_type  = "S"               # Hash key type ("S"=String, "N"=Number, "B"=Binary)
    dynamodb_range_key      = "createdAt"       # Range key attribute name (optional)
    dynamodb_range_key_type = "N"               # Range key type ("S"=String, "N"=Number, "B"=Binary) (optional)
    dynamodb_read_capacity  = 5                 # Read capacity units (for PROVISIONED billing mode)
    dynamodb_write_capacity = 5                 # Write capacity units (for PROVISIONED billing mode)
    dynamodb_billing_mode   = "PROVISIONED"     # Billing mode ("PROVISIONED" or "PAY_PER_REQUEST")
  }
}

# Containers Configuration
# Define your containers here. Each container can have its own settings.
# The 'public' field determines if the container is accessible via the ALB.
# The 'domain' field is used to route traffic to specific containers based on the hostname.
# The 'protocol' field defines the protocol used by the container (e.g., HTTP, HTTPS, TCP).
# Environment variables and secrets can be specified for each container.
# Secrets must be stored in AWS Secrets Manager or Parameter Store.
# Autoscaling can be configured per container. If not specified, autoscaling is disabled.
aws_containers = {
  web = {
    image         = "nginx:latest" # Your custom image
    cpu           = 256            # CPU units (256 = 0.25 vCPU, 512 = 0.5 vCPU, 1024 = 1 vCPU, etc.)
    memory        = 512            # Memory in MB
    port          = 80             # Container port to expose
    health_check  = "/"            # Health check path (OPTIONAL)
    public        = true           # Whether this container is public (accessible via ALB)
    domain        = "example.com"  # Domain or subdomain for routing (e.g., "api.example.com") (OPTIONAL)
    protocol      = "HTTPS"        # Protocol used by the container (e.g., HTTP, HTTPS, TCP)
    desired_count = 2              # Number of desired task instances (OPTIONAL, default is 1)
    environment = {                # Environment variables (OPTIONAL)
      ENVIRONMENT   = "production"
      LOG_LEVEL     = "info"
      API_URL       = "https://api.example.com"
      PORT          = "80"
      MY_CUSTOM_VAR = "custom_value"
    }
    secrets = [ # Secrets from AWS Secrets Manager or Parameter Store (OPTIONAL)
      {
        name      = "DB_PASSWORD"
        valueFrom = "arn:aws:secretsmanager:us-west-2:123456789012:secret:db_password" # ARN of the secret or parameter
      },
      {
        name      = "API_KEY"
        valueFrom = "arn:aws:ssm:us-west-2:123456789012:parameter/api_key" # ARN of the secret or parameter
      }
    ]
    autoscaling = { # Autoscaling configuration (OPTIONAL)
      min_capacity       = 2
      max_capacity       = 5
      target_cpu         = 70
      scale_in_cooldown  = 60
      scale_out_cooldown = 60
    }
  }
  api = {
    image         = "myorg/api:latest"
    cpu           = 512
    memory        = 1024
    port          = 8080
    health_check  = "/health"
    public        = true
    domain        = "api.example.com"
    protocol      = "HTTPS"
    desired_count = 1
    autoscaling = {
      min_capacity       = 1
      max_capacity       = 3
      target_cpu         = 60
      scale_in_cooldown  = 120
      scale_out_cooldown = 120
    }
  }
  worker = {
    image        = "myorg/worker:latest"
    cpu          = 256
    memory       = 512
    port         = 9000
    health_check = "/status"
    public       = false
    protocol     = "HTTP"
  }
}
