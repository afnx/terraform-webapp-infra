##########################################
#            Cloud Providers             #
##########################################
deploy_aws = true

##########################################
#           AWS Configuration            #
##########################################
# AWS Region
aws_region = "us-west-2"

# Tags
aws_tags = {
  Environment = "production"
  Owner       = "your-team"
  Project     = "webapp"
}

# Domain Configuration
aws_domain_name               = "example.com"       # Replace with your actual domain
aws_subject_alternative_names = ["www.example.com"] # Set this to [] if not needed. Can include subdomains.

# VPC Configuration
# Make sure these CIDR blocks do not overlap with your existing network
aws_vpc_cidr                = "10.0.0.0/16"
aws_public_subnet_cidrs     = ["10.0.1.0/24"]
aws_private_subnet_cidrs    = ["10.0.101.0/24"]
aws_vpc_flow_logs_role_name = "VPCFlowLogsRole" # Set a unique IAM role name for VPC Flow Logs.

# Application Load Balancer Configuration
# This is the entry point for all public traffic to your containers
# Adjust security group CIDR blocks as needed for your security requirements
aws_alb_name                       = "webapp-alb"    # Set a unique name for the ALB
aws_alb_security_group_name        = "webapp-alb-sg" # Set a unique name for the ALB security group
aws_alb_security_group_description = "Security group for the Application Load Balancer"
aws_alb_ingress_cidr_blocks_http   = ["0.0.0.0/0"] # Open HTTP to the world or restrict to trusted IPs
aws_alb_ingress_cidr_blocks_https  = ["0.0.0.0/0"] # Open HTTPS to the world or restrict to trusted IPs
aws_alb_egress_cidr_blocks         = ["0.0.0.0/0"] # Allow all outbound traffic or restrict as needed

# ECS Fargate Configuration
# This project uses AWS ECS Fargate to run containers without managing servers
aws_ecs_cluster_name                      = "webapp-cluster"       # Set a unique name for the ECS cluster
aws_ecs_task_execution_role_name          = "ECSTaskExecutionRole" # Set a unique IAM role name for ECS task execution
aws_ecs_security_group_name               = "webapp-ecs-sg"        # Set a unique name for the ECS security group
aws_ecs_security_group_description        = "Security group for ECS tasks"
aws_ecs_security_group_egress_cidr_blocks = ["0.0.0.0/0"]        # Allow all outbound traffic or restrict as needed
aws_ecs_task_definition_family_name       = "webapp-task-family" # Set a unique family name for the ECS task definition
aws_ecs_service_name                      = "webapp-ecs-service" # Set a unique name for the ECS service

# Containers Configuration
# Define your containers here. Each container can have its own settings.
# The 'public' field determines if the container is accessible via the ALB.
# The 'domain' field is used to route traffic to specific containers based on the hostname.
# The 'protocol' field defines the protocol used by the container (e.g., HTTP, HTTPS, TCP).
aws_containers = {
  web = {
    image         = "nginx:latest" # Your custom image
    cpu           = 256            # CPU units (256 = 0.25 vCPU, 512 = 0.5 vCPU, 1024 = 1 vCPU, etc.)
    memory        = 512            # Memory in MB
    port          = 80             # Container port to expose
    health_check  = "/"            # Health check path (OPTIONAL)
    public        = true           # Whether this container is public (accessible via ALB)
    domain        = "example.com"  # Domain or subdomain for routing (e.g., "api.example.com") (OPTIONAL)
    protocol      = "HTTPS"        # Protocol used by the container (e.g., HTTP, HTTPS, TCP)
    desired_count = 2              # Number of desired task instances (OPTIONAL, default is 1)
    autoscaling = {                # Autoscaling configuration (OPTIONAL)
      min_capacity       = 2
      max_capacity       = 5
      target_cpu         = 70
      scale_in_cooldown  = 60
      scale_out_cooldown = 60
    }
  }
  api = {
    image         = "myorg/api:latest"
    cpu           = 512
    memory        = 1024
    port          = 8080
    health_check  = "/health"
    public        = true
    domain        = "api.example.com"
    protocol      = "HTTPS"
    desired_count = 1
    autoscaling = {
      min_capacity       = 1
      max_capacity       = 3
      target_cpu         = 60
      scale_in_cooldown  = 120
      scale_out_cooldown = 120
    }
  }
  worker = {
    image        = "myorg/worker:latest"
    cpu          = 256
    memory       = 512
    port         = 9000
    health_check = "/status"
    public       = false
    protocol     = "HTTP"
  }
}
